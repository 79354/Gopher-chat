'use client';

import { useEffect, useRef, useState, useCallback } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { useWebRTC } from '@/hooks/useWebRTC';
import { useVideoSocket } from '@/hooks/useVideoSocket';
import VideoControls from './VideoControls';
import { X, Maximize2, Minimize2 } from 'lucide-react';
import { cn } from '@/lib/utils';

interface VideoCallProps {
    roomId: string;
    userId: string;
    username: string;
    isGroup?: boolean;
    onClose: () => void;
}

export default function VideoCall({
    roomId,
    userId,
    username,
    isGroup = false,
    onClose
}: VideoCallProps) {
    const [isFullscreen, setIsFullscreen] = useState(false);
    const [isMinimized, setIsMinimized] = useState(false);

    const localVideoRef = useRef<HTMLVideoElement>(null);
    const remoteVideosRef = useRef<Map<string, HTMLVideoElement>>(new Map());

    // Refs to hold the send functions (resolves circular dependency between hooks)
    const sendOfferRef = useRef<((targetId: string, offer: RTCSessionDescriptionInit) => void) | null>(null);
    const sendAnswerRef = useRef<((targetId: string, answer: RTCSessionDescriptionInit) => void) | null>(null);
    const sendICERef = useRef<((targetId: string, candidate: RTCIceCandidateInit) => void) | null>(null);

    // --- 1. Define Signaling Handlers (Socket -> WebRTC) ---

    const handleIncomingOffer = useCallback(async (peerId: string, offer: RTCSessionDescriptionInit) => {
        // When we receive an offer: Create Answer -> Send Answer
        // Note: createAnswer in useWebRTC should handle setting remote desc + creating answer + setting local desc
        // We need to cast the createAnswer return type if necessary, or ensure useWebRTC returns the answer
        console.log(`[VideoCall] Handling offer from ${peerId}`);
        // @ts-ignore - We will fix createAnswer signature in useWebRTC next
        const answer = await createAnswer(peerId, offer);
        if (answer && sendAnswerRef.current) {
            sendAnswerRef.current(peerId, answer);
        }
    }, []); // createAnswer is stable from useWebRTC

    const handleIncomingAnswer = useCallback(async (peerId: string, answer: RTCSessionDescriptionInit) => {
        console.log(`[VideoCall] Handling answer from ${peerId}`);
        await handleRemoteAnswer(peerId, answer);
    }, []);

    const handleIncomingICE = useCallback(async (peerId: string, candidate: RTCIceCandidateInit) => {
        console.log(`[VideoCall] Handling ICE from ${peerId}`);
        await handleICECandidate(peerId, candidate);
    }, []);

    // --- 2. Initialize Hooks ---

    const {
        localStream,
        remoteStreams,
        isAudioMuted,
        isVideoMuted,
        isScreenSharing,
        toggleAudio,
        toggleVideo,
        startScreenShare,
        stopScreenShare,
        createOffer,
        createAnswer,
        handleRemoteAnswer,
        handleICECandidate
    } = useWebRTC(roomId, userId);

    // Note: We are passing our handlers to the socket hook
    const {
        connectionStatus,
        participants,
        sendOffer,
        sendAnswer,
        sendICECandidate
    } = useVideoSocket(
        roomId,
        userId,
        isGroup,
        handleIncomingOffer,
        handleIncomingAnswer,
        handleIncomingICE
    );

    // --- 3. Sync Refs & Logic ---

    // Keep refs updated with the latest send functions from the socket hook
    useEffect(() => {
        sendOfferRef.current = sendOffer;
        sendAnswerRef.current = sendAnswer;
        sendICERef.current = sendICECandidate;
    }, [sendOffer, sendAnswer, sendICECandidate]);

    // Attach local stream to video element
    useEffect(() => {
        if (localStream && localVideoRef.current) {
            localVideoRef.current.srcObject = localStream;
        }
    }, [localStream]);

    // Attach remote streams to video elements
    useEffect(() => {
        remoteStreams.forEach((stream, peerId) => {
            const videoElement = remoteVideosRef.current.get(peerId);
            if (videoElement && stream) {
                videoElement.srcObject = stream;
            }
        });
    }, [remoteStreams]);

    // Cleanup on unmount
    useEffect(() => {
        return () => {
            // Ensure streams are stopped
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
            }
        };
    }, []); // Run once

    // TODO: In the next step, we must update useWebRTC to accept an `onLocalICE` callback 
    // so we can transmit candidates generated by the browser. 
    // Currently useWebRTC just logs them to console.

    // TODO: In the next step, we must update useVideoSocket to expose an `onNewPeer` event
    // so we can initiate offers in Mesh/Group calls.

    const toggleFullscreen = () => {
        setIsFullscreen(!isFullscreen);
    };

    const handleEndCall = () => {
        onClose();
    };

    return (
        <AnimatePresence>
            <motion.div
                initial={{ opacity: 0, scale: 0.9 }}
                animate={{ opacity: 1, scale: 1 }}
                exit={{ opacity: 0, scale: 0.9 }}
                className={cn(
                    "fixed bg-slate-950 rounded-2xl shadow-2xl border border-white/10 overflow-hidden z-50",
                    isFullscreen && "inset-0 rounded-none",
                    isMinimized && "bottom-4 right-4 w-80 h-60",
                    !isFullscreen && !isMinimized && "inset-10"
                )}
                drag={!isFullscreen}
                dragConstraints={{ left: 0, right: 0, top: 0, bottom: 0 }}
                dragElastic={0.1}
            >
                {/* Header */}
                <div className="absolute top-0 left-0 right-0 z-10 bg-gradient-to-b from-black/80 to-transparent p-4 flex justify-between items-center handle cursor-move">
                    <div>
                        <h3 className="text-white font-semibold flex items-center gap-2">
                            {isGroup ? `Group Call` : username}
                            <span className="bg-white/10 px-2 py-0.5 rounded text-xs text-gray-300 font-normal">
                                {participants.length} in call
                            </span>
                        </h3>
                        <p className="text-xs text-gray-400">
                            {connectionStatus === 'connected' ? 'ðŸŸ¢ Connected' : 'ðŸŸ¡ Connecting...'}
                        </p>
                    </div>

                    <div className="flex gap-2">
                        <button
                            onClick={() => setIsMinimized(!isMinimized)}
                            className="p-2 hover:bg-white/10 rounded-lg transition-colors text-white"
                        >
                            {isMinimized ? <Maximize2 size={20} /> : <Minimize2 size={20} />}
                        </button>
                        <button
                            onClick={toggleFullscreen}
                            className="p-2 hover:bg-white/10 rounded-lg transition-colors text-white"
                        >
                            <Maximize2 size={20} />
                        </button>
                        <button
                            onClick={handleEndCall}
                            className="p-2 hover:bg-red-500/20 rounded-lg transition-colors text-red-400"
                        >
                            <X size={20} />
                        </button>
                    </div>
                </div>

                {/* Video Grid */}
                <div className={cn(
                    "relative w-full h-full bg-slate-900",
                    isGroup || remoteStreams.size > 0 ? "grid grid-cols-2 md:grid-cols-3 gap-2 p-4 pt-20 pb-24" : "flex items-center justify-center"
                )}>
                    {/* Remote Videos */}
                    {Array.from(remoteStreams.entries()).map(([peerId, stream]) => (
                        <div
                            key={peerId}
                            className="relative bg-slate-800 rounded-lg overflow-hidden aspect-video shadow-lg border border-white/5"
                        >
                            <video
                                ref={(el) => {
                                    if (el) {
                                        el.srcObject = stream;
                                        remoteVideosRef.current.set(peerId, el);
                                    } else {
                                        remoteVideosRef.current.delete(peerId);
                                    }
                                }}
                                autoPlay
                                playsInline
                                className="w-full h-full object-cover"
                            />
                            <div className="absolute bottom-2 left-2 bg-black/60 backdrop-blur-sm px-2 py-1 rounded text-xs text-white">
                                Remote User ({peerId.slice(0, 4)})
                            </div>
                        </div>
                    ))}

                    {/* Waiting State */}
                    {remoteStreams.size === 0 && (
                        <div className="text-center text-gray-500 flex flex-col items-center">
                            <div className="w-16 h-16 rounded-full bg-white/5 flex items-center justify-center mb-4 animate-pulse">
                                <Maximize2 className="opacity-50" />
                            </div>
                            <p>Waiting for others to join...</p>
                        </div>
                    )}

                    {/* Local Video (Picture-in-Picture) */}
                    <motion.div
                        className="absolute bottom-24 right-4 w-48 h-36 bg-slate-800 rounded-lg overflow-hidden border-2 border-white/20 shadow-2xl z-20"
                        drag
                        dragConstraints={{ left: 0, right: 0, top: 0, bottom: 0 }}
                    >
                        <video
                            ref={localVideoRef}
                            autoPlay
                            muted
                            playsInline
                            className={cn(
                                "w-full h-full object-cover",
                                !isScreenSharing && "mirror"
                            )}
                        />
                        <div className="absolute top-2 left-2 bg-black/50 px-2 py-1 rounded text-xs text-white">
                            You {isScreenSharing && "(Sharing)"}
                        </div>
                    </motion.div>
                </div>

                {/* Controls */}
                <div className="absolute bottom-0 left-0 right-0 bg-gradient-to-t from-black/90 via-black/50 to-transparent p-6 pt-12 z-30">
                    <VideoControls
                        isAudioMuted={isAudioMuted}
                        isVideoMuted={isVideoMuted}
                        isScreenSharing={isScreenSharing}
                        onToggleAudio={toggleAudio}
                        onToggleVideo={toggleVideo}
                        onStartScreenShare={startScreenShare}
                        onStopScreenShare={stopScreenShare}
                        onEndCall={handleEndCall}
                    />
                </div>
            </motion.div>
        </AnimatePresence>
    );
}